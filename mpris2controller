#!/usr/bin/env python3

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
import dbus
import dbus.service
import logging

# DBus interface and path constants
MPRIS_PATH = "/org/mpris/MediaPlayer2"
MPRIS_INTERFACE = "org.mpris.MediaPlayer2.Player"
MY_PATH = "/org/icasdri/mpris2controller"
MY_INTERFACE = "org.icasdri.mpris2controller"

# Tags to add to players
UNKNOWN = "Unknown"
IS_PLAYING = "Playing"
WAS_PLAYING = "Was playing"
NOT_PLAYING = "Not playing"

log = logging.getLogger(__name__)
class PlayerList:
    def __init__(self, bus):
        self.bus = bus
        self.playing = set()
        self.not_playing = []
        self.proxies = dict()

        # Detect and add all players on bus
        log.info("Detecting players already on bus and determining "
              "playback status...")
        for p in filter(lambda x: x.find("org.mpris.MediaPlayer2") == 0,
                        bus.list_names()):
            self.add(p)
        self.printout()

    def add_new_player(self, name):
        # Add to front of non-playing, can be moved out if propman says so with markas_playing
        self.not_playing.insert(0, name)

    def markas_playing(self, name):
        # Add to playing
        try:
            self.not_playing.remove(name)
        except ValueError:
            pass
        if name not in self.playing:
            self.playing.add(name)

    def markas_not_playing(self, name):
        # Add to back of non-playing
        self.playing.discard(name)
        if name not in self.not_playing:
            self.not_playing.append(name)

    def call_on_all_playing(self, method_name):
        # Loops through all in playing and calls method
        for n in self.playing:
            self.bus.get_object(n, MPRIS_PATH).__getattr__(method_name)()

    def call_on_one_playing(self, method_name):
        # Calls on one in playing, only if there is only one playing
        if len(self.playing) == 1:
            self.call_on_all_playing(method_name)

    def call_on_head_not_playing(self, method_name):
        # Pops/peeks first off back of non-playing and calls method
        if len(self.not_playing) > 0:
            self.bus.get_object(self.not_playing[-1], MPRIS_PATH).__getattr__(method_name)()

    def add(self, name):
        proxy = self.bus.get_object(name, MPRIS_PATH)
        prop_man = dbus.Interface(proxy, 'org.freedesktop.DBus.Properties')
        try:
            playback_status = prop_man.Get(MPRIS_INTERFACE, "PlaybackStatus")
        except dbus.DBusException:
            print("Could not determine playback status of {}".format(
                  proxy.bus_name))
            proxy.status = UNKNOWN
        else:
            if playback_status == "Playing":
                proxy.status = IS_PLAYING
            else:
                proxy.status = NOT_PLAYING
        self.proxies[proxy.bus_name] = proxy

    def remove(self, unique_bus_name):
        del self.proxies[unique_bus_name]

    def get(self, unique_bus_name):
        if self.has(unique_bus_name):
            return self.proxies[unique_bus_name]
        else:
            return None

    def has(self, unique_bus_name):
        return unique_bus_name in self.proxies

    def all_players(self):
        return self.proxies.values()

    def all_is_playing(self):
        return filter(lambda x: x.status == IS_PLAYING, self.all_players())

    def all_was_playing(self):
        return filter(lambda x: x.status == WAS_PLAYING,
                      self.all_players())

    def single_is_playing(self):
        """
        Return the only player on the bus that is playing, otherwise if
        there is more than one player on the bus that is playing or if
        there are no players playing, return None
        """
        all_is_playing = self.all_is_playing()
        p1 = next(all_is_playing, None)
        if p1 is not None:
            p2 = next(all_is_playing, None)
            if p2 is None:
                return p1
        return None

    def printout(self):
        for n, p in self.proxies.items():
            print("{} -- {}".format(n, p.status))
        print()


class Controller(dbus.service.Object):
    def __init__(self, bus):
        self.bus = bus
        bus_name = dbus.service.BusName(MY_INTERFACE, bus=self.bus)
        dbus.service.Object.__init__(self, bus_name, MY_PATH)
        self.bus.add_signal_receiver(
            signal_name="PropertiesChanged",
            handler_function=self.handle_signal_properties_changed,
            path=MPRIS_PATH,
            sender_keyword='sender')
        self.bus.add_signal_receiver(
            signal_name="NameOwnerChanged",
            handler_function=self.handle_signal_name_change,
            path=dbus.BUS_DAEMON_PATH,
            sender_keyword='sender')
        self.players = PlayerList(self.bus)

    @dbus.service.method(dbus_interface=MY_INTERFACE)
    def PlayPause(self):
        print("Method PlayPause called")
        had_playing = False
        # If there is a player playing on this method call, this will loop
        # through them and pause them
        for p in self.players.all_is_playing():
            p.Pause()
            had_playing = True
        # If there wasn't a player playing on this method call
        if not had_playing:
            # If there's only one player on the bus, play that
            if len(self.players.all_players()) == 1:
                p = next(iter(self.players.all_players()))
                p.Play()
            # Otherwise play the one that WAS_PLAYING
            else:
                for p in self.players.all_was_playing():
                    p.Play()

    @dbus.service.method(dbus_interface=MY_INTERFACE)
    def Next(self):
        print("Method Next called")
        p = self.players.single_is_playing()
        if p is not None:
            p.Next()

    @dbus.service.method(dbus_interface=MY_INTERFACE)
    def Previous(self):
        print("Method Prev called")
        p = self.players.single_is_playing()
        if p is not None:
            p.Previous()

    def handle_signal_properties_changed(self, interface, props, sig, sender=None):
        if interface == MPRIS_INTERFACE:
            if not self.players.has(sender):
                print("Detected new player {}".format(sender))
                self.players.add(sender)
            if "PlaybackStatus" in props:
                print("Got signal from {}".format(sender))
                proxy = self.players.get(sender)
                if props["PlaybackStatus"] == "Playing":
                    proxy.status = IS_PLAYING
                else:
                    if proxy.status == IS_PLAYING:
                        for p in self.players.all_was_playing():
                            p.status = NOT_PLAYING
                        proxy.status = WAS_PLAYING
                self.players.printout()

    def handle_signal_name_change(self, name, old_name, new_name, sender=None):
        if sender == dbus.BUS_DAEMON_NAME:
            if self.players.has(name) and self.players.has(old_name) and new_name == "":
                print("Player", name, "no longer exists!")
                self.players.remove(name)
                self.players.printout()
            #print(name, ":", old_name, "is now", new_name)


if __name__ == "__main__":
    from dbus.mainloop.glib import DBusGMainLoop
    from gobject import MainLoop
    DBusGMainLoop(set_as_default=True)
    Controller(dbus.SessionBus())
    MainLoop().run()
